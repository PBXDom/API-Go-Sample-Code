/* 
 * <PBXDom API>
 *
 * OpenAPI spec version: 2.1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package swagger

import (
	"strings"
	"fmt"
	"errors"
	"net/url"
	"encoding/json"
)

type DefaultApi struct {
	Configuration Configuration
}

func NewDefaultApi() *DefaultApi {
	configuration := NewConfiguration()
	return &DefaultApi{
		Configuration: *configuration,
	}
}

func NewDefaultApiWithBasePath(basePath string) *DefaultApi {
	configuration := NewConfiguration()
	configuration.BasePath = basePath

	return &DefaultApi{
		Configuration: *configuration,
	}
}

/**
 * 
 * Gets &#x60;Calls&#x60; info. 
 *
 * @param rptType Report type. (0 report, 1 widget, 2 chart).
 * @param rptId Report id.
 * @param start Start offset.
 * @param limit Number of results to return. Max 10K.
 * @param sortBy Sort column.
 * @param sortType Sort mode asc/desc.
 * @param fromDate Start date time.
 * @param toDate End date time.
 * @param duration Duration range.
 * @param phone List of caller phone.
 * @param phone1 List of dialled phones.
 * @param co List of trunk/co.
 * @param ext list of extensions.
 * @param pbxId list of PBX Ids.
 * @param callSource list of callsource.
 * @param callType list of call type signatures.(5 Unanswered Calls, 7 Transfered Calls, 8 Forwarded Calls)
 * @param direction list of direction.(0 incoming, 1 outgoing, 2 internal)
 * @param callerName list of caller name.
 * @param did list of did.
 * @param dnis list of dnis.
 * @param acc list of account code.
 * @param ring Ring range.Seconds unit.
 * @param cost Cost range.
 * @param group Department/Group id.
 * @return []InlineResponse200
 */
func (a DefaultApi) CallsGet(rptType float64, rptId float64, start float32, limit float32, sortBy string, sortType string, fromDate string, toDate string, duration float32, phone string, phone1 string, co string, ext string, pbxId float32, callSource float32, callType float32, direction float32, callerName string, did string, dnis string, acc string, ring float32, cost float32, group float32) ([]InlineResponse200, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/Calls"

	// verify the required parameter 'rptType' is set
	if &rptType == nil {
		return new([]InlineResponse200), nil, errors.New("Missing required parameter 'rptType' when calling DefaultApi->CallsGet")
	}
	// verify the required parameter 'rptId' is set
	if &rptId == nil {
		return new([]InlineResponse200), nil, errors.New("Missing required parameter 'rptId' when calling DefaultApi->CallsGet")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}
		queryParams.Add("rptType", a.Configuration.APIClient.ParameterToString(rptType, ""))
			queryParams.Add("rptId", a.Configuration.APIClient.ParameterToString(rptId, ""))
			queryParams.Add("start", a.Configuration.APIClient.ParameterToString(start, ""))
			queryParams.Add("limit", a.Configuration.APIClient.ParameterToString(limit, ""))
			queryParams.Add("sortBy", a.Configuration.APIClient.ParameterToString(sortBy, ""))
			queryParams.Add("sortType", a.Configuration.APIClient.ParameterToString(sortType, ""))
			queryParams.Add("fromDate", a.Configuration.APIClient.ParameterToString(fromDate, ""))
			queryParams.Add("toDate", a.Configuration.APIClient.ParameterToString(toDate, ""))
			queryParams.Add("duration", a.Configuration.APIClient.ParameterToString(duration, ""))
			queryParams.Add("phone", a.Configuration.APIClient.ParameterToString(phone, ""))
			queryParams.Add("phone1", a.Configuration.APIClient.ParameterToString(phone1, ""))
			queryParams.Add("co", a.Configuration.APIClient.ParameterToString(co, ""))
			queryParams.Add("ext", a.Configuration.APIClient.ParameterToString(ext, ""))
			queryParams.Add("pbxId", a.Configuration.APIClient.ParameterToString(pbxId, ""))
			queryParams.Add("callSource", a.Configuration.APIClient.ParameterToString(callSource, ""))
			queryParams.Add("callType", a.Configuration.APIClient.ParameterToString(callType, ""))
			queryParams.Add("direction", a.Configuration.APIClient.ParameterToString(direction, ""))
			queryParams.Add("callerName", a.Configuration.APIClient.ParameterToString(callerName, ""))
			queryParams.Add("did", a.Configuration.APIClient.ParameterToString(did, ""))
			queryParams.Add("dnis", a.Configuration.APIClient.ParameterToString(dnis, ""))
			queryParams.Add("acc", a.Configuration.APIClient.ParameterToString(acc, ""))
			queryParams.Add("ring", a.Configuration.APIClient.ParameterToString(ring, ""))
			queryParams.Add("cost", a.Configuration.APIClient.ParameterToString(cost, ""))
			queryParams.Add("group", a.Configuration.APIClient.ParameterToString(group, ""))
	

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
			}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new([]InlineResponse200)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * 
 * Gets &#x60;Charts&#x60; list. 
 *
 * @return []InlineResponse200
 */
func (a DefaultApi) FeaturesChartsGet() ([]InlineResponse200, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/Features/charts"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
			}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new([]InlineResponse200)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * 
 * Gets &#x60;Reports&#x60; list. 
 *
 * @return []InlineResponse200
 */
func (a DefaultApi) FeaturesReportsGet() ([]InlineResponse200, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/Features/reports"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
			}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new([]InlineResponse200)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

/**
 * 
 * Gets &#x60;Widgets&#x60; list. 
 *
 * @return []InlineResponse200
 */
func (a DefaultApi) FeaturesWidgetGet() ([]InlineResponse200, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.Configuration.BasePath + "/Features/widget"


	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte

	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		headerParams[key] = a.Configuration.DefaultHeader[key]
	}


	// to determine the Content-Type header
	localVarHttpContentTypes := []string{  }

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
			}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new([]InlineResponse200)
	httpResponse, err := a.Configuration.APIClient.CallAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return *successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

